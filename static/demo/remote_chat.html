<html>

<head>
    <title>RemoteVideoChatDemo</title>
    <style>
        video {
            top: 0;
            left: 0;
            width: 480px;
            height: 320px;
            border: 1px solid black;
        }
        canvas {
            top: 90px;
            left: 10px;
            position: absolute;
        }
        div {
            display: inline-block;
        }
        button {
            margin: 0 1em 0 0;
            width: 5.2em;
        }
        
    </style>

    <script type="text/javascript" src="../js/jquery.min.js"></script>
    <script src="/static/js/socket.io.js"></script>
    <script src="/static/js/face-api.min.js"></script>
    <!-- echarts.js -->
    <script src="/static/js/echarts.js"></script>
</head>

<body>
    <div style="width: 100%;vertical-align: top;">
        <div>
            <video id="localVideo" autoplay="autoplay" playsinline="true" controls muted></video>
            <video id="remoteVideo" playsinline="true" autoplay="autoplay" controls style="margin-left: 20px;"></video>
            <div id="main" style="width: 600px;height:400px;"></div>
        </div>
    </div>

    <button id="joinBtn">joinRoom</button>
    <button id="leaveBtn" disabled="true">leaveRoom</button>
    <button id="downloadBtn" disabled="">Download</button>

    <script>
        
        Promise.all([
            faceapi.nets.tinyFaceDetector.loadFromUri('/static/models'),
            faceapi.nets.faceLandmark68Net.loadFromUri('/static/models'),
            faceapi.nets.faceRecognitionNet.loadFromUri('/static/models'),
            faceapi.nets.faceExpressionNet.loadFromUri('/static/models')
        ]).then(console.log("load models")).catch(e=>console.log(e))
            
        var myChart = echarts.init(document.getElementById('main'));

        var localVideo = document.getElementById('localVideo');
        var remoteVideo = document.getElementById('remoteVideo');

        var joinButton = $("#joinBtn");
        var leaveButton = $("#leaveBtn");

        var room = "";
        var state = "offline";
        var socket = null;

        var roomId = -1;
        var targetSocket = null;

        var pcConfig = {
            'iceServers': [{
                url: 'stun:stun.l.google.com:19302',
            }]
        }
        var pc = null;  //Local PeerConnection Object
        var localStream = null;
        var remoteStream = null;
        var offerDesc = null;
        var outputEmotion = null;

        joinButton.click(function () {
            room = prompt("ROOM number：")

            if (room == "") {
                return;
            }

            joinButton.attr('disabled', true);
            leaveButton.attr('disabled', false);

            doJoinRoom(room);
        });

        leaveButton.click(function () {
            joinButton.attr('disabled', false);
            leaveButton.attr('disabled', true);

            doLeaveRoom();
        });

        
        function doJoinRoom(room) {
            //init socketio
            var serverHost = "https://" + window.location.host;
            socket = io(serverHost)
            console.log(socket);
            setupSocketIO();

            socket.emit("join", room);
        }

        function setupSocketIO() {
            //Socket handler
            socket.on("joined", (roomid, socketid) => {
                console.log("recieve msg: ", roomid, " ", socketid);
                roomId = roomid;

                if (socket.id == socketid) {
                    //if send to self, join
                    
                    //obtain local stream
                    var constraints = {
                        video: {
                            width: 640,
                            height: 480
                        },
                        audio: {
                            echoCancellation: true,
                            noiseSupperssion: true,
                            autoGainControl: true
                        }
                    };
                    // Get video stream
                    navigator.mediaDevices.getUserMedia(constraints)
                        .then(getMediaStream)
                        .catch(handleError);
                } else {
                    //new User
                    console.log('new user joined room: ', socketid);

                    if(targetSocket == null) {
                        targetSocket = socketid;
                    }
                }
            });

            socket.on("ready", (roomid, socketid)=> {
                //the other is ready
                if(socketid == targetSocket) {
                    console.log("target reday");
                    startCall();
                }
            })

            socket.on("full", (roomid)=>{
                alert("full：" + roomid);
                socket.disconnect();
                socket = null;
            });

            socket.on('leaved', (roomid, socketid)=> {
                console.log("user leave room: " + socketid);
                if(socketid == socket.id) {
                    hangup();
                    socket.disconnect();
                    socket = null;

                    localVideo.srcObject = null;
                } else {
                    remoteVideo.srcObject = null;
                    targetSocket = null;
                    //re init local PeerConnection object
                    hangup();
                    initLocal();
                }
            });

            socket.on('message', (roomid, socketid, msg)=>{
                if(msg === null || msg === undefined) {
                    console.error("Recieve invalid message");
                    return;
                }

                //ignore message from self
                if(socketid == socket.id) {
                    return;
                }

                console.log(pc);
                // message handler
                if(msg.hasOwnProperty('type') && msg.type === 'offer') {
                    pc.setRemoteDescription(new RTCSessionDescription(msg));

                    //if the msg is an offer, then create anwser
                    pc.createAnswer().then(getAnswer).catch(handleAnswerError);

                } else if(msg.hasOwnProperty('type') && msg.type ==='answer') {
                    pc.setRemoteDescription(new RTCSessionDescription(msg));

                } else if(msg.hasOwnProperty('type') && msg.type === 'candidate') {
                    console.log("candidate:", msg);
                    // receive a new candidate description from remote RTCPeer
                    var candidate = new RTCIceCandidate({
                        sdpMLineIndex: msg.label,
                        candidate: msg.candidate
                    });
                    pc.addIceCandidate(candidate);
                } else {
                    console.log('Invalid message', msg);
                }
            });
        }

        //leave room
        function doLeaveRoom() {
            if(socket) {
                //alert(roomId);
                socket.emit("leave", roomId);
            } else {
                console.error("socket not init!");
            }
        }

        function getMediaStream(stream) {
            if (localStream) {
                stream.getAudioTracks().forEach((track) => {
                    localStream.addTrack(track);
                    stream.removeTrack(track);
                });
            } else {
                localStream = stream;
            }

            localVideo.srcObject = localStream;

            initLocal();
            return;
        }

        
        // echart and data visualize
        var option = {
            title: {
                text: 'Emotional Detection'
            },
            tooltip: {},
            legend: {
                data:['emotion']
            },
            xAxis: {
                data: ["angry","disgusted","fearful","happy","neural","sad","suprised"],
                axisLabel:{
                    show: true,
                    interval: 0
                }
                
            },
            axisLabel:{
                show: true
            },

            yAxis: {},
            series: [{
                name: 'emotion',
                type: 'bar',
                data: [7,6,5,4,3,2,1]
            }]
        };

        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);

        var detections = null;
        var canvas = null;
        localVideo.addEventListener('play',() =>{
            showEmotion()  
        })

        function detectFace() {
            canvas = faceapi.createCanvasFromMedia(localVideo)
            document.body.append(canvas)
            const displaySize = {width: 480, height: 320}
            faceapi.matchDimensions(canvas, displaySize)
            
            return new Promise(function(resolve){
                setInterval(async()=>{
                    detections = await faceapi.detectSingleFace(localVideo,
                    new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceExpressions()
                    // console.log(detections[0].expressions.happy)
                    const resizedDetections = faceapi.resizeResults(detections,displaySize)
                    // canvas.getContext('2d').drawImage(localVideo, 0, 0, 480, 320)
                    canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height) 
                    faceapi.draw.drawDetections(canvas, resizedDetections)
                    faceapi.draw.drawFaceLandmarks(canvas, resizedDetections)
                    faceapi.draw.drawFaceExpressions(canvas, resizedDetections)
                    var option = myChart.getOption();
                    option.series[0].data = [detections.expressions.angry,
                    detections.expressions.disgusted,
                    detections.expressions.fearful,
                    detections.expressions.happy,
                    detections.expressions.neutral,
                    detections.expressions.sad,
                    detections.expressions.surprised,
                    ];
                    
                    console.log(detections.expressions);
                    myChart.setOption(option);
                    resolve(detections)
                }, 500)
            })
           
        }
        
        
        async function showEmotion(){ 
            detections = detectFace();
               
        }   
        

        function initLocal() {
            //Create local PeerConnection
            createPeerConnection();
            //track
            bindTracks();

            //tell the other peer we get ready
            socket.emit("ready", roomId);
        }

        function handleError(err) {
            console.error('Failed to get media stream: ', err);
        }

        //创建PeerConnection
        function createPeerConnection() {
            console.log("create RTCPeerConnection");

            if (!pc) {
                pc = new RTCPeerConnection(pcConfig);
                // type of EventHandler for event icecandidate
                // it would get called when a new ICE Candidate is available
                // triggered when get answer from remote and going to send candidate info to remote
                pc.onicecandidate = (e) => {
                    if (e.candidate) {
                        (roomId, {
                            type: 'candidate',
                            label: event.candidate.sdpMLineIndex,
                            id: event.candidate.sdpMid,
                            candidate: event.candidate.candidate
                        });
                    } else {
                        console.log("end candidate");
                    }
                };
                
                // Once remote track arrives show it in remote element
                pc.ontrack = getRemoteStream;
                setupDataChannel();
            }

        }

        function setupDataChannel() {
            var dataChannelOptions = null;

            var dataChannel = pc.createDataChannel("dataChannel", dataChannelOptions);

            dataChannel.onerror = function (error) {
                console.log("Data Channel Error:", error);
            };

            dataChannel.onmessage = function (event) {
                console.log("Got Data Channel Message:", event.data);
            };

            dataChannel.onopen = function () {
                dataChannel.send("Hello World!");
            };

            dataChannel.onclose = function () {
                console.log("The Data Channel is Closed");
            };
        }

        function bindTracks() {
            console.log("bind tracks into RTCPeerConnection");

            if (pc === null || localStream === null || localStream === undefined) {
                console.error('pc or localStream is null or undefined');
                return;
            }

            localStream.getTracks().forEach((track) => {
                pc.addTrack(track, localStream);
            });
        }

        function getRemoteStream(e) {
            console.log("getremoteStream")
            remoteStream = e.streams[0];
            remoteVideo.srcObject = remoteStream;
        }

        function hangup() {
            if(!pc) {
                return;
            }

            pc.close();
            pc = null;
        }

        function sendMessage(roomid, data) {
            if (!socket) {
                console.log('socket is null');
                return;
            }

            socket.emit('message', roomid, data);
        }

        function startCall() {
            var offerOptions = {
                offerToRecieveAudio :1,
                offerToRecieveVideo:1
            }

            pc.createOffer(offerOptions).then(getOffer).catch(handleOfferError);
        }

        //As a caller, creating the offer
        function getOffer(sdp) {
            pc.setLocalDescription(sdp);

            offerDesc = sdp;

            //send to other peer
            sendMessage(roomId, offerDesc);
        }

        function handleOfferError(error) {
            console.error('create offer failed: ', error);
        }

        // As callee, want to answer the offer
        function getAnswer(sdp) {
            pc.setLocalDescription(sdp);

            sendMessage(roomId, sdp);
        }

        function handleAnswerError(error) {
            console.error('create answer failed: ', error);
        }
    </script>
</body>

</html>